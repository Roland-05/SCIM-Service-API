from sqlmodel import SQLModel, Session, Field as SQLField, Relationship
from pydantic import BaseModel, Field as APIField
from typing import Optional
from datetime import datetime

class Name(SQLModel, table = True):
    id: int | None = SQLField(default=None, primary_key = True)
    formatted: Optional[str]
    familyName: str # required
    givenName: str # required
    middleName: Optional[str] 
    honorificPrefix: Optional[str]
    honorificSuffix: Optional[str]

    user_id: int | None = SQLField(default=None, foreign_key="user.id")
    user: "User" = Relationship(back_populates="name")


class Email(SQLModel, table=True):
    id: int | None = SQLField(default=None, primary_key = True)
    value: str # the email address
    display: Optional[str]
    type: Optional[str]
    primary: Optional[bool] = False

    user_id: int | None = SQLField(default=None, foreign_key="user.id")
    user: "User" = Relationship(back_populates="emails")

class Meta(SQLModel, table = True):
    id: int | None = SQLField(default = None, primary_key=True)
    resourceType: str = "user"
    created: datetime = SQLField(default_factory=datetime.datetime.utcnow, nullable = False)
    lastModified: datetime = SQLField(default_factory=datetime.datetime.utcnow, nullable=False)
    location: Optional[str] # URL of resource

    # Foreign key with unique=True constraint (one Meta object per User)
    user_id: int | None = SQLField(default=None, foreign_key="user.id", unique=True)
    user: "User" = Relationship(back_populates="meta")


class Address(SQLModel, table=True):
    id: int | None = SQLField(default=None, primary_key=True)

    # Optional Fields from SCIM standard
    formatted: Optional[str] = None
    streetAddress: Optional[str] = None
    locality: Optional[str] = None # City/ Suburb
    region: Optional[str] = None # State/Region
    postalCode: Optional[str] = None
    country: Optional[str] = None
    type: Optional[str] = None # e.g. 'work', 'home'
    primary: Optional[bool] = None 

    user_id: Optional[int] = SQLField(default=None, foreign_key="user.id")
    user: "User" = Relationship(back_populates="addresses")

class User(SQLModel, table = True):
    id: int | None = SQLField(default = None, primary_key = True) 
    externalId: Optional[str]
    userName: str = SQLField(unique=True, index=True)
    displayName: Optional[str]
    active: Optional[bool] = True

    # Optional fields
    locale: Optional[str] | None = None
    timezone: Optional[str] | None = None
    nickName: Optional[str] | None = None
    profileUrl: Optional[str] | None = None
    title: Optional[str] | None = None
    userType: Optional[str] | None = None

   # required: Defines the schema URIs this resource uses
    schemas: list[str] = SQLField(default_factory=lambda: ["urn:ietf:params:scim:schemas:core:2.0:User"])

    # Parent side relationships
    name: Optional[Name] = Relationship(back_populates="user")
    emails: list[Email] = Relationship(back_populates="user")
    addresses: list[Address] = Relationship(back_populates="user")
    meta: Optional[Meta] = Relationship(back_populates="user")


#API Sub-Schema

class NameScim(BaseModel):
    formatted: Optional[str]
    familyName: str
    givenName: str
    middleName: Optional[str]
    honorificPrefix: Optional[str]
    honorificSuffix: Optional[str]

class EmailScim(BaseModel):
    value:str
    display:Optional[str]
    type: Optional[str]
    primary: Optional[bool]

class MetaScim(BaseModel):
    #Output/ GET
    resourceType: str
    created: datetime
    lastModified: datetime 
    location: Optional[str]

class AddressScim(BaseModel):
    # All fields are optional
    formatted: Optional[str] = None
    streetAddress: Optional[str] = None
    streetAddress: Optional[str] = None
    locality: Optional[str] = None
    region: Optional[str] = None
    postalCode: Optional[str] = None
    country: Optional[str] = None
    type: Optional[str] = None
    primary: Optional[bool] = None # Defaulting to None/NULL in DB

# Main API Schemas

# POST request
# Define the expected JSON input, which does not include system-generated IDs
class UserCreate(BaseModel):
    externalId: Optional[str]
    userName: str
    displayName: Optional[str]
    active: Optional[bool] = True

    # Nested Schemas

    name: Optional[NameScim] = None
    # use validation constraint mandated by the SCIM RFC
    emails: list[EmailScim] = APIField(min_items=1) # SCIM requires at least one email
    addresses: list[AddressScim] = None

# GET response schema
# Defines the output JSON structure. It includes ID and Meta fields generated by the system
class UserPublic(BaseModel):

    id: str
    externalId: Optional[str] = None
    userName: str
    displayName: Optional[str] = None
    active: Optional[bool] = True

    # Nested schema
    name: Optional[NameScim] = None
    emails: list[EmailScim] = None
    meta: MetaScim

    # map data from SQLModel to ORM object
    model_config = {"from_attributes": True}







